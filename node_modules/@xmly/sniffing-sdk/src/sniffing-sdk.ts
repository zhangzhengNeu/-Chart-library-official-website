import { bindEventListener, getTrackParams, transFormTrackParams, pathIsEqual } from './util'
import routerObserver from './routerObserver'
import Exposure from './exposure'
import { Options, TrackerMap, TrackerEvent, TrackParams, RouterObject } from './types/index'
import Log from './eventLog'
import * as ERROR from './ERROR'
import _ from 'lodash'
const HANDLEROUTER = Symbol('handleRouterUbt')
const INITTRACK = Symbol('initTrack')
const ONCLICK = Symbol('onClick')
const EXCUTEUBTTTACKER = Symbol('excuteUbtTracker')
export const sdkVersion = 'process.env.VERSION'

class SniffingClass {
  public options: Options
  public trackerEvents: Array<TrackerEvent>
  public _init: boolean
  public _autoExpo: boolean
  public _originMap: TrackerMap
  public expo: any //曝光埋点实例
  public routerObserver: any //页面生命周期实例
  constructor() {
    this.options = {
      autoExpo: false,
      autoPageTracker: true,
      isDebugger: false
    }
    this.trackerEvents = []
    this._originMap = {}
    this._init = false
    this._autoExpo = false
    this.expo = null
    this.routerObserver = null
  }

  /**
   * @description: 处理xmrep对象
   * @param {any} xmrepInstance
   * @param {any} options
   * @param {boolean} isReturn
   * @return {*}
   */

  public xmrep(xmrepInstance: any, options: any = {}, isReturn: boolean = true) {
    const customCommon = options.c || {}
    xmrepInstance(
      Object.assign(options, {
        c: {
          ...customCommon,
          sdkVersion: 'process.env.VERSION'
        }
      })
    )
    if (isReturn) {
      return this
    }
  }
  /**
   * @description: 初始化埋点sdk，重复初始化会提示
   * @param {TrackerMap} trackerMap
   * @param {Options} options
   * @return {*} 埋点实例
   */
  public init(trackerMap: TrackerMap, options?: Options): SniffingClass {
    if (!(options && options.xmrep && options.xmrep.params && options.xmrep.params.b)) {
      console.error(
        'please check your config of sniffing-sdk, the bid is required, more infomation in http://thoughts.ximalaya.com/workspaces/5f6c3795931e49001d29240f/docs/5ff6aa88f4c0000001c4c2db'
      )
    }
    if (this._init) {
      this.log(ERROR.ENVIRONMENT.REPEAT, 'warn')
      return this
    }
    this._init = true
    this.install(trackerMap, false)
    this.options = Object.assign({}, this.options, options)
    // 初始化xmrep
    this.options.xmrep && this.xmrep(this.options.xmrep.start, this.options.xmrep.params, false)
    this[INITTRACK](this.options)
    return this
  }

  /**
   * @description: 合并配置和处理注册事件表
   * @param {TrackerMap} trackerMap
   * @param {Options} options
   * @param {Boolean} extend
   * @return {*}
   */
  public install(trackerMap: TrackerMap, extend: Boolean = true) {
    if (!this._init) {
      this.log(ERROR.NOTFOUND.SniffingNotReady, 'warn')
      return this
    }
    this._originMap = extend ? Object.assign({}, this._originMap, trackerMap) : trackerMap
    this.trackerEvents = Object.keys(this._originMap).map(item => ({
      id: item.split(' ')[0],
      label: item.split(' ')[1],
      pathname: item.split(' ')[2],
      cb: this._originMap[item]
    }))

    if (extend) {
      return this
    }
  }

  public [HANDLEROUTER](routerObj: RouterObject) {
    // 路由pathname匹配并且label为enter或者leave
    const routerEvent = this.trackerEvents
      .filter(
        item =>
          (routerObj.currentPath &&
            pathIsEqual(routerObj.currentPath, item.pathname) &&
            item.label === 'enter') ||
          (routerObj.refererPath &&
            pathIsEqual(routerObj.refererPath, item.pathname) &&
            item.label === 'leave')
      )
      .sort((a: TrackerEvent, b: TrackerEvent) => {
        // 先处理leave逻辑，然后处理enter逻辑
        return a.label < b.label ? 0 : -1
      })
    if (routerEvent.length > 0) {
      routerEvent.forEach(item => item.cb(routerObj))
    } else {
      if (this.options.autoTrack) {
        this.log(`autoTracker (pageEvent: ${routerObj.ext.action})`, 'warn')
        this.options.autoTrack('PAGE', routerObj)
      }
    }
  }

  public [INITTRACK](options: Options) {
    bindEventListener('click', this[ONCLICK].bind(this), window ? window.document : null, {
      passive: false
    })
    if (options.autoPageTracker) {
      this[HANDLEROUTER]({
        currentPath:
          (options.router && options.router.type) === 'hash'
            ? window.location.hash
            : window.location.pathname,
        ext: {
          current: window.location,
          action: 'DOMContentLoaded'
        }
      })
      this.routerObserver = routerObserver(this.options.router)
      this.routerObserver.onChange((routerObj: RouterObject) => {
        this[HANDLEROUTER](routerObj)
      })
    }
    options.autoExpo && this.initExpo()
  }
  /**
   * @description: 初始化曝光埋点
   * @param {*}
   * @return {*} this
   */

  public initExpo() {
    this.options.autoExpo = true
    if (this._autoExpo) {
      return this
    }
    this.expo = new Exposure(this[EXCUTEUBTTTACKER].bind(this))
    this._autoExpo = true
    return this
  }
  /**
   * @description: 注册点击埋点
   * @param {Event} e
   * @return {*}
   */
  [ONCLICK](e: Event) {
    const target = getTrackParams(e)
    if (target) {
      const { ubtClick } = target.dataset
      ubtClick && this[EXCUTEUBTTTACKER](transFormTrackParams(target.dataset))
    }
  }
  /**
   * 执行事件
   * @param trackParams
   */
  [EXCUTEUBTTTACKER](trackParams: TrackParams) {
    const findOne = this.trackerEvents.filter((item: TrackerEvent) =>
      trackParams.evId.includes(item.id)
    )
    if (findOne.length) {
      findOne.forEach(item => item.cb(trackParams.evParams || {}, trackParams))
    } else {
      if (this.options.autoTrack) {
        this.log(`autoTracker (click id: ${trackParams.evId})`, 'info')
        this.options.autoTrack('CLICK', trackParams.evParams || {}, trackParams)
      } else {
        this.log(`${ERROR.NOTFOUND.UnregistedId}(id: ${trackParams.evId})`, 'warn')
      }
    }
  }
  /**
   * @description: 手动曝光方法
   * @param {string} ubtId
   * @param {object} ubtParams
   * @return {*}
   */
  manualTrack(evId: string | Array<string> | number, ubtParams?: object) {
    this[EXCUTEUBTTTACKER](transFormTrackParams({ evId, ubtParams, evTrigger: 'event' }))
  }
  /**
   * @description: log
   * @param {any} text
   * @param {*} level  "info" | "warn" | "error" = "info"
   * @return {*}
   */

  public log(text: any, level: 'info' | 'warn' | 'error' = 'info') {
    Log('Sniffing-sdk: ', this.options.isDebugger)(text, level)
  }
}
export default SniffingClass
