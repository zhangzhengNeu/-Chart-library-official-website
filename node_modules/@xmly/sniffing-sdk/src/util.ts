import { TrackParams } from './types/index'
import * as ERROR from './ERROR'
import { pathToRegexp, match, parse, compile } from 'path-to-regexp'
/**
 * @description: 判断对象上是否有addEventListener方法
 * @param {object}
 * @return {boolean}
 */
export const isListenerType1 = (target: any): boolean => {
  return !!target.addEventListener
}

/**
 * @description: 判断对象上是否有on方法
 * @param {object}
 * @return {boolean}
 */
export const isListenerType2 = (target: any): boolean => {
  return !!target.on
}
/**
 * @description:
 * @param {string} name
 * @param {*} handle
 * @param {*} target
 * @param {*} options
 * @return {*}
 */
export const bindEventListener = (
  name: string,
  handler: (e: any) => void,
  target?: any,
  options?: any
) => {
  if (!target) {
    return false
  }
  if (isListenerType1(target)) {
    target.addEventListener(name, handler, options)
  } else if (isListenerType2(target)) {
    target.on(name, handler, options)
  }
}

/**
 * @description: 判断当前dataset对象是否符合点击埋点dataset(data-ubt-id或者data-ubt-click)
 * @param {TrackParams} obj
 * @return {*}
 */
export const isValidSniffingDom = (obj: TrackParams | any) =>
  obj && Object.keys(obj).length > 0 && obj.ubtClick

/**
 * @description: 判断是否是合法的曝光标签
 * @param {TrackParams} obj
 * @return {*}
 */
export const isValidSniffingExpoDom = (obj: TrackParams | any) =>
  obj && Object.keys(obj).length > 0 && obj.ubtExpo

export const isExpoed = (obj: any) => {
  return obj.expoStatus === 'finished'
}

export const getTrackParams = (e: any) => {
  if (!isValidSniffingDom(e.target.dataset)) {
    return lookUpParent(e.path || e.deepPath || e.target)
  }
  return e.target
}

/**
 * @description: 模拟冒泡获取合法的TrackParams对象
 * @param {any} routeOrTarget
 * @return {any}
 */
export const lookUpParent = (routeOrTarget: any) => {
  if (Array.isArray(routeOrTarget)) {
    return routeOrTarget.find(d => isValidSniffingDom(d.dataset))
  }
  const maxLookupDepth = 200

  if (routeOrTarget) {
    let tmpNode = routeOrTarget
    let lookupDepth = 1
    do {
      if (isValidSniffingDom(tmpNode.dataset)) {
        return tmpNode
      }
      if (lookupDepth > maxLookupDepth) {
        return null
      }
      tmpNode = tmpNode.parentNode
      lookupDepth++
    } while (tmpNode)
  }

  return null
}

export const transFormTrackParams = (dataset: any): TrackParams => {
  let formatEv = {
    evId: dataset.evId || dataset.ubtClick || dataset.ubtExpo,
    evParams: dataset.evParams || dataset.ubtParams,
    evTrigger: dataset.evTrigger || 'click'
  }
  if (!(formatEv.evId instanceof Array)) {
    formatEv.evId = (formatEv.evId + '')
      .replace(' ', ',')
      .split(',')
      .filter(Boolean)
  }
  try {
    formatEv.evParams = formatEv.evParams
      ? typeof formatEv.evParams === 'object'
        ? formatEv.evParams
        : JSON.parse(formatEv.evParams)
      : null
  } catch (err) {
    console.error(ERROR.EXCEPTION.ParamsParseError, err)
  }
  return formatEv
}

export const transFormExpoTrackParams = (params: any) =>
  transFormTrackParams({
    ubtExpo: params.ubtExpo,
    evParams: params.ubtParams,
    evTrigger: 'expo'
  })

/**
 * 当前环境判断
 * 为兼容ssr因此使用方法
 */
export const env = () => ({
  isIos: !!navigator.userAgent.toLowerCase().match(/\(i[^;]+;( u;)? cpu.+mac os x/),
  isBrowser: typeof window !== 'undefined'
})

export const pathIsEqual = (path: string, rep?: string) => {
  if (!rep) return false
  const matchBrowserUrl = match(rep, { decode: decodeURIComponent })
  return matchBrowserUrl(path)
}
